// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import { BaseClientOptions, makePrismaClientClass, Model } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  favourite: (where?: FavouriteWhereInput) => Promise<boolean>;
  follow: (where?: FollowWhereInput) => Promise<boolean>;
  imageData: (where?: ImageDataWhereInput) => Promise<boolean>;
  like: (where?: LikeWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  voiceData: (where?: VoiceDataWhereInput) => Promise<boolean>;
  work: (where?: WorkWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  favourite: (where: FavouriteWhereUniqueInput) => FavouriteNullablePromise;
  favourites: (args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Favourite>;
  favouritesConnection: (args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FavouriteConnectionPromise;
  follow: (where: FollowWhereUniqueInput) => FollowNullablePromise;
  follows: (args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Follow>;
  followsConnection: (args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FollowConnectionPromise;
  imageData: (where: ImageDataWhereUniqueInput) => ImageDataNullablePromise;
  imageDatas: (args?: {
    where?: ImageDataWhereInput;
    orderBy?: ImageDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ImageData>;
  imageDatasConnection: (args?: {
    where?: ImageDataWhereInput;
    orderBy?: ImageDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageDataConnectionPromise;
  like: (where: LikeWhereUniqueInput) => LikeNullablePromise;
  likes: (args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Like>;
  likesConnection: (args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LikeConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportNullablePromise;
  reports: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Report>;
  reportsConnection: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  voiceData: (where: VoiceDataWhereUniqueInput) => VoiceDataNullablePromise;
  voiceDatas: (args?: {
    where?: VoiceDataWhereInput;
    orderBy?: VoiceDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VoiceData>;
  voiceDatasConnection: (args?: {
    where?: VoiceDataWhereInput;
    orderBy?: VoiceDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoiceDataConnectionPromise;
  work: (where: WorkWhereUniqueInput) => WorkNullablePromise;
  works: (args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Work>;
  worksConnection: (args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createFavourite: (data: FavouriteCreateInput) => FavouritePromise;
  updateFavourite: (args: {
    data: FavouriteUpdateInput;
    where: FavouriteWhereUniqueInput;
  }) => FavouritePromise;
  upsertFavourite: (args: {
    where: FavouriteWhereUniqueInput;
    create: FavouriteCreateInput;
    update: FavouriteUpdateInput;
  }) => FavouritePromise;
  deleteFavourite: (where: FavouriteWhereUniqueInput) => FavouritePromise;
  deleteManyFavourites: (where?: FavouriteWhereInput) => BatchPayloadPromise;
  createFollow: (data: FollowCreateInput) => FollowPromise;
  updateFollow: (args: {
    data: FollowUpdateInput;
    where: FollowWhereUniqueInput;
  }) => FollowPromise;
  upsertFollow: (args: {
    where: FollowWhereUniqueInput;
    create: FollowCreateInput;
    update: FollowUpdateInput;
  }) => FollowPromise;
  deleteFollow: (where: FollowWhereUniqueInput) => FollowPromise;
  deleteManyFollows: (where?: FollowWhereInput) => BatchPayloadPromise;
  createImageData: (data: ImageDataCreateInput) => ImageDataPromise;
  updateImageData: (args: {
    data: ImageDataUpdateInput;
    where: ImageDataWhereUniqueInput;
  }) => ImageDataPromise;
  updateManyImageDatas: (args: {
    data: ImageDataUpdateManyMutationInput;
    where?: ImageDataWhereInput;
  }) => BatchPayloadPromise;
  upsertImageData: (args: {
    where: ImageDataWhereUniqueInput;
    create: ImageDataCreateInput;
    update: ImageDataUpdateInput;
  }) => ImageDataPromise;
  deleteImageData: (where: ImageDataWhereUniqueInput) => ImageDataPromise;
  deleteManyImageDatas: (where?: ImageDataWhereInput) => BatchPayloadPromise;
  createLike: (data: LikeCreateInput) => LikePromise;
  updateLike: (args: {
    data: LikeUpdateInput;
    where: LikeWhereUniqueInput;
  }) => LikePromise;
  upsertLike: (args: {
    where: LikeWhereUniqueInput;
    create: LikeCreateInput;
    update: LikeUpdateInput;
  }) => LikePromise;
  deleteLike: (where: LikeWhereUniqueInput) => LikePromise;
  deleteManyLikes: (where?: LikeWhereInput) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (args: {
    data: ReportUpdateInput;
    where: ReportWhereUniqueInput;
  }) => ReportPromise;
  updateManyReports: (args: {
    data: ReportUpdateManyMutationInput;
    where?: ReportWhereInput;
  }) => BatchPayloadPromise;
  upsertReport: (args: {
    where: ReportWhereUniqueInput;
    create: ReportCreateInput;
    update: ReportUpdateInput;
  }) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVoiceData: (data: VoiceDataCreateInput) => VoiceDataPromise;
  updateVoiceData: (args: {
    data: VoiceDataUpdateInput;
    where: VoiceDataWhereUniqueInput;
  }) => VoiceDataPromise;
  updateManyVoiceDatas: (args: {
    data: VoiceDataUpdateManyMutationInput;
    where?: VoiceDataWhereInput;
  }) => BatchPayloadPromise;
  upsertVoiceData: (args: {
    where: VoiceDataWhereUniqueInput;
    create: VoiceDataCreateInput;
    update: VoiceDataUpdateInput;
  }) => VoiceDataPromise;
  deleteVoiceData: (where: VoiceDataWhereUniqueInput) => VoiceDataPromise;
  deleteManyVoiceDatas: (where?: VoiceDataWhereInput) => BatchPayloadPromise;
  createWork: (data: WorkCreateInput) => WorkPromise;
  updateWork: (args: {
    data: WorkUpdateInput;
    where: WorkWhereUniqueInput;
  }) => WorkPromise;
  updateManyWorks: (args: {
    data: WorkUpdateManyMutationInput;
    where?: WorkWhereInput;
  }) => BatchPayloadPromise;
  upsertWork: (args: {
    where: WorkWhereUniqueInput;
    create: WorkCreateInput;
    update: WorkUpdateInput;
  }) => WorkPromise;
  deleteWork: (where: WorkWhereUniqueInput) => WorkPromise;
  deleteManyWorks: (where?: WorkWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  favourite: (
    where?: FavouriteSubscriptionWhereInput
  ) => FavouriteSubscriptionPayloadSubscription;
  follow: (
    where?: FollowSubscriptionWhereInput
  ) => FollowSubscriptionPayloadSubscription;
  imageData: (
    where?: ImageDataSubscriptionWhereInput
  ) => ImageDataSubscriptionPayloadSubscription;
  like: (
    where?: LikeSubscriptionWhereInput
  ) => LikeSubscriptionPayloadSubscription;
  report: (
    where?: ReportSubscriptionWhereInput
  ) => ReportSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  voiceData: (
    where?: VoiceDataSubscriptionWhereInput
  ) => VoiceDataSubscriptionPayloadSubscription;
  work: (
    where?: WorkSubscriptionWhereInput
  ) => WorkSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FollowOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WorkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "visibility_ASC"
  | "visibility_DESC"
  | "views_ASC"
  | "views_DESC"
  | "usage_ASC"
  | "usage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Role = "ADMIN" | "CARETAKER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LikeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FavouriteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ImageDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileUrl_ASC"
  | "fileUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VoiceDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileUrl_ASC"
  | "fileUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface VoiceDataUpsertWithWhereUniqueWithoutWorkInput {
  where: VoiceDataWhereUniqueInput;
  update: VoiceDataUpdateWithoutWorkDataInput;
  create: VoiceDataCreateWithoutWorkInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutFavouritesInput {
  create?: Maybe<UserCreateWithoutFavouritesInput>;
  update?: Maybe<UserUpdateWithoutFavouritesDataInput>;
  upsert?: Maybe<UserUpsertWithoutFavouritesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FollowWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  following?: Maybe<UserWhereInput>;
  followers?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FollowWhereInput[] | FollowWhereInput>;
  OR?: Maybe<FollowWhereInput[] | FollowWhereInput>;
  NOT?: Maybe<FollowWhereInput[] | FollowWhereInput>;
}

export interface UserUpdateWithoutFavouritesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface ImageDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileUrl?: Maybe<String>;
  fileUrl_not?: Maybe<String>;
  fileUrl_in?: Maybe<String[] | String>;
  fileUrl_not_in?: Maybe<String[] | String>;
  fileUrl_lt?: Maybe<String>;
  fileUrl_lte?: Maybe<String>;
  fileUrl_gt?: Maybe<String>;
  fileUrl_gte?: Maybe<String>;
  fileUrl_contains?: Maybe<String>;
  fileUrl_not_contains?: Maybe<String>;
  fileUrl_starts_with?: Maybe<String>;
  fileUrl_not_starts_with?: Maybe<String>;
  fileUrl_ends_with?: Maybe<String>;
  fileUrl_not_ends_with?: Maybe<String>;
  work?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageDataWhereInput[] | ImageDataWhereInput>;
  OR?: Maybe<ImageDataWhereInput[] | ImageDataWhereInput>;
  NOT?: Maybe<ImageDataWhereInput[] | ImageDataWhereInput>;
}

export interface WorkUpdateManyWithoutUserInput {
  create?: Maybe<WorkCreateWithoutUserInput[] | WorkCreateWithoutUserInput>;
  delete?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  connect?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  set?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  disconnect?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  update?: Maybe<
    | WorkUpdateWithWhereUniqueWithoutUserInput[]
    | WorkUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | WorkUpsertWithWhereUniqueWithoutUserInput[]
    | WorkUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<WorkScalarWhereInput[] | WorkScalarWhereInput>;
  updateMany?: Maybe<
    WorkUpdateManyWithWhereNestedInput[] | WorkUpdateManyWithWhereNestedInput
  >;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  work?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface WorkUpdateManyWithoutCategoryInput {
  create?: Maybe<
    WorkCreateWithoutCategoryInput[] | WorkCreateWithoutCategoryInput
  >;
  delete?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  connect?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  set?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  disconnect?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
  update?: Maybe<
    | WorkUpdateWithWhereUniqueWithoutCategoryInput[]
    | WorkUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | WorkUpsertWithWhereUniqueWithoutCategoryInput[]
    | WorkUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<WorkScalarWhereInput[] | WorkScalarWhereInput>;
  updateMany?: Maybe<
    WorkUpdateManyWithWhereNestedInput[] | WorkUpdateManyWithWhereNestedInput
  >;
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface WorkUpdateWithWhereUniqueWithoutCategoryInput {
  where: WorkWhereUniqueInput;
  data: WorkUpdateWithoutCategoryDataInput;
}

export interface WorkUpdateWithWhereUniqueWithoutUserInput {
  where: WorkWhereUniqueInput;
  data: WorkUpdateWithoutUserDataInput;
}

export interface WorkUpdateWithoutCategoryDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface FavouriteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  work?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FavouriteWhereInput[] | FavouriteWhereInput>;
  OR?: Maybe<FavouriteWhereInput[] | FavouriteWhereInput>;
  NOT?: Maybe<FavouriteWhereInput[] | FavouriteWhereInput>;
}

export interface UserUpdateOneRequiredWithoutWorksInput {
  create?: Maybe<UserCreateWithoutWorksInput>;
  update?: Maybe<UserUpdateWithoutWorksDataInput>;
  upsert?: Maybe<UserUpsertWithoutWorksInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserUpdateWithoutWorksDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface LikeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  work?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeWhereInput[] | LikeWhereInput>;
  OR?: Maybe<LikeWhereInput[] | LikeWhereInput>;
  NOT?: Maybe<LikeWhereInput[] | LikeWhereInput>;
}

export interface LikeUpdateManyWithoutUserInput {
  create?: Maybe<LikeCreateWithoutUserInput[] | LikeCreateWithoutUserInput>;
  delete?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  set?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  disconnect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  update?: Maybe<
    | LikeUpdateWithWhereUniqueWithoutUserInput[]
    | LikeUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | LikeUpsertWithWhereUniqueWithoutUserInput[]
    | LikeUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  works_every?: Maybe<WorkWhereInput>;
  works_some?: Maybe<WorkWhereInput>;
  works_none?: Maybe<WorkWhereInput>;
  likes_every?: Maybe<LikeWhereInput>;
  likes_some?: Maybe<LikeWhereInput>;
  likes_none?: Maybe<LikeWhereInput>;
  favourites_every?: Maybe<FavouriteWhereInput>;
  favourites_some?: Maybe<FavouriteWhereInput>;
  favourites_none?: Maybe<FavouriteWhereInput>;
  reports_every?: Maybe<ReportWhereInput>;
  reports_some?: Maybe<ReportWhereInput>;
  reports_none?: Maybe<ReportWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  following_every?: Maybe<FollowWhereInput>;
  following_some?: Maybe<FollowWhereInput>;
  following_none?: Maybe<FollowWhereInput>;
  followers_every?: Maybe<FollowWhereInput>;
  followers_some?: Maybe<FollowWhereInput>;
  followers_none?: Maybe<FollowWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface LikeUpdateWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput;
  data: LikeUpdateWithoutUserDataInput;
}

export interface FollowSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FollowWhereInput>;
  AND?: Maybe<FollowSubscriptionWhereInput[] | FollowSubscriptionWhereInput>;
  OR?: Maybe<FollowSubscriptionWhereInput[] | FollowSubscriptionWhereInput>;
  NOT?: Maybe<FollowSubscriptionWhereInput[] | FollowSubscriptionWhereInput>;
}

export interface LikeUpdateWithoutUserDataInput {
  work?: Maybe<WorkUpdateOneRequiredWithoutLikesInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface WorkUpdateOneRequiredWithoutLikesInput {
  create?: Maybe<WorkCreateWithoutLikesInput>;
  update?: Maybe<WorkUpdateWithoutLikesDataInput>;
  upsert?: Maybe<WorkUpsertWithoutLikesInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface WorkWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  visibility_not?: Maybe<Boolean>;
  views?: Maybe<Int>;
  views_not?: Maybe<Int>;
  views_in?: Maybe<Int[] | Int>;
  views_not_in?: Maybe<Int[] | Int>;
  views_lt?: Maybe<Int>;
  views_lte?: Maybe<Int>;
  views_gt?: Maybe<Int>;
  views_gte?: Maybe<Int>;
  usage?: Maybe<Int>;
  usage_not?: Maybe<Int>;
  usage_in?: Maybe<Int[] | Int>;
  usage_not_in?: Maybe<Int[] | Int>;
  usage_lt?: Maybe<Int>;
  usage_lte?: Maybe<Int>;
  usage_gt?: Maybe<Int>;
  usage_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  imageDatas_every?: Maybe<ImageDataWhereInput>;
  imageDatas_some?: Maybe<ImageDataWhereInput>;
  imageDatas_none?: Maybe<ImageDataWhereInput>;
  voiceDatas_every?: Maybe<VoiceDataWhereInput>;
  voiceDatas_some?: Maybe<VoiceDataWhereInput>;
  voiceDatas_none?: Maybe<VoiceDataWhereInput>;
  likes_every?: Maybe<LikeWhereInput>;
  likes_some?: Maybe<LikeWhereInput>;
  likes_none?: Maybe<LikeWhereInput>;
  favourites_every?: Maybe<FavouriteWhereInput>;
  favourites_some?: Maybe<FavouriteWhereInput>;
  favourites_none?: Maybe<FavouriteWhereInput>;
  reports_every?: Maybe<ReportWhereInput>;
  reports_some?: Maybe<ReportWhereInput>;
  reports_none?: Maybe<ReportWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<WorkWhereInput[] | WorkWhereInput>;
  OR?: Maybe<WorkWhereInput[] | WorkWhereInput>;
  NOT?: Maybe<WorkWhereInput[] | WorkWhereInput>;
}

export interface WorkUpdateWithoutLikesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface WorkUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface CategoryUpdateOneRequiredWithoutWorksInput {
  create?: Maybe<CategoryCreateWithoutWorksInput>;
  update?: Maybe<CategoryUpdateWithoutWorksDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutWorksInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface VoiceDataUpdateManyMutationInput {
  fileUrl?: Maybe<String>;
}

export interface CategoryUpdateWithoutWorksDataInput {
  name?: Maybe<String>;
}

export interface WorkUpsertWithoutVoiceDatasInput {
  update: WorkUpdateWithoutVoiceDatasDataInput;
  create: WorkCreateWithoutVoiceDatasInput;
}

export interface CategoryUpsertWithoutWorksInput {
  update: CategoryUpdateWithoutWorksDataInput;
  create: CategoryCreateWithoutWorksInput;
}

export interface WorkUpdateOneRequiredWithoutVoiceDatasInput {
  create?: Maybe<WorkCreateWithoutVoiceDatasInput>;
  update?: Maybe<WorkUpdateWithoutVoiceDatasDataInput>;
  upsert?: Maybe<WorkUpsertWithoutVoiceDatasInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface ImageDataUpdateManyWithoutWorkInput {
  create?: Maybe<
    ImageDataCreateWithoutWorkInput[] | ImageDataCreateWithoutWorkInput
  >;
  delete?: Maybe<ImageDataWhereUniqueInput[] | ImageDataWhereUniqueInput>;
  connect?: Maybe<ImageDataWhereUniqueInput[] | ImageDataWhereUniqueInput>;
  set?: Maybe<ImageDataWhereUniqueInput[] | ImageDataWhereUniqueInput>;
  disconnect?: Maybe<ImageDataWhereUniqueInput[] | ImageDataWhereUniqueInput>;
  update?: Maybe<
    | ImageDataUpdateWithWhereUniqueWithoutWorkInput[]
    | ImageDataUpdateWithWhereUniqueWithoutWorkInput
  >;
  upsert?: Maybe<
    | ImageDataUpsertWithWhereUniqueWithoutWorkInput[]
    | ImageDataUpsertWithWhereUniqueWithoutWorkInput
  >;
  deleteMany?: Maybe<ImageDataScalarWhereInput[] | ImageDataScalarWhereInput>;
  updateMany?: Maybe<
    | ImageDataUpdateManyWithWhereNestedInput[]
    | ImageDataUpdateManyWithWhereNestedInput
  >;
}

export interface VoiceDataUpdateInput {
  fileUrl?: Maybe<String>;
  work?: Maybe<WorkUpdateOneRequiredWithoutVoiceDatasInput>;
}

export interface ImageDataUpdateWithWhereUniqueWithoutWorkInput {
  where: ImageDataWhereUniqueInput;
  data: ImageDataUpdateWithoutWorkDataInput;
}

export interface WorkCreateOneWithoutVoiceDatasInput {
  create?: Maybe<WorkCreateWithoutVoiceDatasInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface ImageDataUpdateWithoutWorkDataInput {
  fileUrl?: Maybe<String>;
}

export interface VoiceDataCreateInput {
  id?: Maybe<ID_Input>;
  fileUrl: String;
  work: WorkCreateOneWithoutVoiceDatasInput;
}

export interface ImageDataUpsertWithWhereUniqueWithoutWorkInput {
  where: ImageDataWhereUniqueInput;
  update: ImageDataUpdateWithoutWorkDataInput;
  create: ImageDataCreateWithoutWorkInput;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface ImageDataScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileUrl?: Maybe<String>;
  fileUrl_not?: Maybe<String>;
  fileUrl_in?: Maybe<String[] | String>;
  fileUrl_not_in?: Maybe<String[] | String>;
  fileUrl_lt?: Maybe<String>;
  fileUrl_lte?: Maybe<String>;
  fileUrl_gt?: Maybe<String>;
  fileUrl_gte?: Maybe<String>;
  fileUrl_contains?: Maybe<String>;
  fileUrl_not_contains?: Maybe<String>;
  fileUrl_starts_with?: Maybe<String>;
  fileUrl_not_starts_with?: Maybe<String>;
  fileUrl_ends_with?: Maybe<String>;
  fileUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageDataScalarWhereInput[] | ImageDataScalarWhereInput>;
  OR?: Maybe<ImageDataScalarWhereInput[] | ImageDataScalarWhereInput>;
  NOT?: Maybe<ImageDataScalarWhereInput[] | ImageDataScalarWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface ImageDataUpdateManyWithWhereNestedInput {
  where: ImageDataScalarWhereInput;
  data: ImageDataUpdateManyDataInput;
}

export interface ReportUpdateInput {
  reason?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutReportsInput>;
  work?: Maybe<WorkUpdateOneRequiredWithoutReportsInput>;
}

export interface ImageDataUpdateManyDataInput {
  fileUrl?: Maybe<String>;
}

export interface ReportCreateInput {
  id?: Maybe<ID_Input>;
  reason: String;
  user: UserCreateOneWithoutReportsInput;
  work: WorkCreateOneWithoutReportsInput;
}

export interface VoiceDataUpdateManyWithoutWorkInput {
  create?: Maybe<
    VoiceDataCreateWithoutWorkInput[] | VoiceDataCreateWithoutWorkInput
  >;
  delete?: Maybe<VoiceDataWhereUniqueInput[] | VoiceDataWhereUniqueInput>;
  connect?: Maybe<VoiceDataWhereUniqueInput[] | VoiceDataWhereUniqueInput>;
  set?: Maybe<VoiceDataWhereUniqueInput[] | VoiceDataWhereUniqueInput>;
  disconnect?: Maybe<VoiceDataWhereUniqueInput[] | VoiceDataWhereUniqueInput>;
  update?: Maybe<
    | VoiceDataUpdateWithWhereUniqueWithoutWorkInput[]
    | VoiceDataUpdateWithWhereUniqueWithoutWorkInput
  >;
  upsert?: Maybe<
    | VoiceDataUpsertWithWhereUniqueWithoutWorkInput[]
    | VoiceDataUpsertWithWhereUniqueWithoutWorkInput
  >;
  deleteMany?: Maybe<VoiceDataScalarWhereInput[] | VoiceDataScalarWhereInput>;
  updateMany?: Maybe<
    | VoiceDataUpdateManyWithWhereNestedInput[]
    | VoiceDataUpdateManyWithWhereNestedInput
  >;
}

export interface LikeCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutLikesInput;
  work: WorkCreateOneWithoutLikesInput;
}

export interface VoiceDataUpdateWithWhereUniqueWithoutWorkInput {
  where: VoiceDataWhereUniqueInput;
  data: VoiceDataUpdateWithoutWorkDataInput;
}

export interface ImageDataUpdateManyMutationInput {
  fileUrl?: Maybe<String>;
}

export interface VoiceDataUpdateWithoutWorkDataInput {
  fileUrl?: Maybe<String>;
}

export interface WorkUpdateWithoutImageDatasDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface CommentUpdateInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  work?: Maybe<WorkUpdateOneRequiredWithoutCommentsInput>;
}

export interface WorkUpdateOneRequiredWithoutImageDatasInput {
  create?: Maybe<WorkCreateWithoutImageDatasInput>;
  update?: Maybe<WorkUpdateWithoutImageDatasDataInput>;
  upsert?: Maybe<WorkUpsertWithoutImageDatasInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface VoiceDataScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileUrl?: Maybe<String>;
  fileUrl_not?: Maybe<String>;
  fileUrl_in?: Maybe<String[] | String>;
  fileUrl_not_in?: Maybe<String[] | String>;
  fileUrl_lt?: Maybe<String>;
  fileUrl_lte?: Maybe<String>;
  fileUrl_gt?: Maybe<String>;
  fileUrl_gte?: Maybe<String>;
  fileUrl_contains?: Maybe<String>;
  fileUrl_not_contains?: Maybe<String>;
  fileUrl_starts_with?: Maybe<String>;
  fileUrl_not_starts_with?: Maybe<String>;
  fileUrl_ends_with?: Maybe<String>;
  fileUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VoiceDataScalarWhereInput[] | VoiceDataScalarWhereInput>;
  OR?: Maybe<VoiceDataScalarWhereInput[] | VoiceDataScalarWhereInput>;
  NOT?: Maybe<VoiceDataScalarWhereInput[] | VoiceDataScalarWhereInput>;
}

export interface WorkCreateWithoutImageDatasInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface VoiceDataUpdateManyWithWhereNestedInput {
  where: VoiceDataScalarWhereInput;
  data: VoiceDataUpdateManyDataInput;
}

export type VoiceDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface VoiceDataUpdateManyDataInput {
  fileUrl?: Maybe<String>;
}

export interface FollowUpdateInput {
  following?: Maybe<UserUpdateOneRequiredWithoutFollowingInput>;
  followers?: Maybe<UserUpdateOneRequiredWithoutFollowersInput>;
}

export interface FavouriteUpdateManyWithoutWorkInput {
  create?: Maybe<
    FavouriteCreateWithoutWorkInput[] | FavouriteCreateWithoutWorkInput
  >;
  delete?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  connect?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  set?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  disconnect?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  update?: Maybe<
    | FavouriteUpdateWithWhereUniqueWithoutWorkInput[]
    | FavouriteUpdateWithWhereUniqueWithoutWorkInput
  >;
  upsert?: Maybe<
    | FavouriteUpsertWithWhereUniqueWithoutWorkInput[]
    | FavouriteUpsertWithWhereUniqueWithoutWorkInput
  >;
  deleteMany?: Maybe<FavouriteScalarWhereInput[] | FavouriteScalarWhereInput>;
}

export type WorkWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FavouriteUpdateWithWhereUniqueWithoutWorkInput {
  where: FavouriteWhereUniqueInput;
  data: FavouriteUpdateWithoutWorkDataInput;
}

export interface FavouriteCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutFavouritesInput;
  work: WorkCreateOneWithoutFavouritesInput;
}

export interface FavouriteUpdateWithoutWorkDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutFavouritesInput>;
}

export interface WorkCreateManyWithoutCategoryInput {
  create?: Maybe<
    WorkCreateWithoutCategoryInput[] | WorkCreateWithoutCategoryInput
  >;
  connect?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  works_every?: Maybe<WorkWhereInput>;
  works_some?: Maybe<WorkWhereInput>;
  works_none?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface UserCreateOneWithoutWorksInput {
  create?: Maybe<UserCreateWithoutWorksInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface VoiceDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileUrl?: Maybe<String>;
  fileUrl_not?: Maybe<String>;
  fileUrl_in?: Maybe<String[] | String>;
  fileUrl_not_in?: Maybe<String[] | String>;
  fileUrl_lt?: Maybe<String>;
  fileUrl_lte?: Maybe<String>;
  fileUrl_gt?: Maybe<String>;
  fileUrl_gte?: Maybe<String>;
  fileUrl_contains?: Maybe<String>;
  fileUrl_not_contains?: Maybe<String>;
  fileUrl_starts_with?: Maybe<String>;
  fileUrl_not_starts_with?: Maybe<String>;
  fileUrl_ends_with?: Maybe<String>;
  fileUrl_not_ends_with?: Maybe<String>;
  work?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VoiceDataWhereInput[] | VoiceDataWhereInput>;
  OR?: Maybe<VoiceDataWhereInput[] | VoiceDataWhereInput>;
  NOT?: Maybe<VoiceDataWhereInput[] | VoiceDataWhereInput>;
}

export interface LikeCreateManyWithoutUserInput {
  create?: Maybe<LikeCreateWithoutUserInput[] | LikeCreateWithoutUserInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  work: WorkCreateOneWithoutCommentsInput;
}

export interface WorkCreateOneWithoutLikesInput {
  create?: Maybe<WorkCreateWithoutLikesInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface ReportWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  work?: Maybe<WorkWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  OR?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  NOT?: Maybe<ReportWhereInput[] | ReportWhereInput>;
}

export interface CategoryCreateOneWithoutWorksInput {
  create?: Maybe<CategoryCreateWithoutWorksInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface WorkUpdateWithoutUserDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface ImageDataCreateManyWithoutWorkInput {
  create?: Maybe<
    ImageDataCreateWithoutWorkInput[] | ImageDataCreateWithoutWorkInput
  >;
  connect?: Maybe<ImageDataWhereUniqueInput[] | ImageDataWhereUniqueInput>;
}

export interface LikeUpdateManyWithoutWorkInput {
  create?: Maybe<LikeCreateWithoutWorkInput[] | LikeCreateWithoutWorkInput>;
  delete?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  set?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  disconnect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  update?: Maybe<
    | LikeUpdateWithWhereUniqueWithoutWorkInput[]
    | LikeUpdateWithWhereUniqueWithoutWorkInput
  >;
  upsert?: Maybe<
    | LikeUpsertWithWhereUniqueWithoutWorkInput[]
    | LikeUpsertWithWhereUniqueWithoutWorkInput
  >;
  deleteMany?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface VoiceDataCreateManyWithoutWorkInput {
  create?: Maybe<
    VoiceDataCreateWithoutWorkInput[] | VoiceDataCreateWithoutWorkInput
  >;
  connect?: Maybe<VoiceDataWhereUniqueInput[] | VoiceDataWhereUniqueInput>;
}

export interface LikeUpdateWithWhereUniqueWithoutWorkInput {
  where: LikeWhereUniqueInput;
  data: LikeUpdateWithoutWorkDataInput;
}

export interface FavouriteCreateManyWithoutWorkInput {
  create?: Maybe<
    FavouriteCreateWithoutWorkInput[] | FavouriteCreateWithoutWorkInput
  >;
  connect?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
}

export interface LikeUpdateWithoutWorkDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutLikesInput>;
}

export interface UserCreateOneWithoutFavouritesInput {
  create?: Maybe<UserCreateWithoutFavouritesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutLikesInput {
  create?: Maybe<UserCreateWithoutLikesInput>;
  update?: Maybe<UserUpdateWithoutLikesDataInput>;
  upsert?: Maybe<UserUpsertWithoutLikesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface WorkCreateManyWithoutUserInput {
  create?: Maybe<WorkCreateWithoutUserInput[] | WorkCreateWithoutUserInput>;
  connect?: Maybe<WorkWhereUniqueInput[] | WorkWhereUniqueInput>;
}

export interface UserUpdateWithoutLikesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface LikeCreateManyWithoutWorkInput {
  create?: Maybe<LikeCreateWithoutWorkInput[] | LikeCreateWithoutWorkInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
}

export interface FavouriteUpdateManyWithoutUserInput {
  create?: Maybe<
    FavouriteCreateWithoutUserInput[] | FavouriteCreateWithoutUserInput
  >;
  delete?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  connect?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  set?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  disconnect?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
  update?: Maybe<
    | FavouriteUpdateWithWhereUniqueWithoutUserInput[]
    | FavouriteUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | FavouriteUpsertWithWhereUniqueWithoutUserInput[]
    | FavouriteUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<FavouriteScalarWhereInput[] | FavouriteScalarWhereInput>;
}

export interface UserCreateOneWithoutLikesInput {
  create?: Maybe<UserCreateWithoutLikesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FavouriteUpdateWithWhereUniqueWithoutUserInput {
  where: FavouriteWhereUniqueInput;
  data: FavouriteUpdateWithoutUserDataInput;
}

export interface FavouriteCreateManyWithoutUserInput {
  create?: Maybe<
    FavouriteCreateWithoutUserInput[] | FavouriteCreateWithoutUserInput
  >;
  connect?: Maybe<FavouriteWhereUniqueInput[] | FavouriteWhereUniqueInput>;
}

export interface FavouriteUpdateWithoutUserDataInput {
  work?: Maybe<WorkUpdateOneRequiredWithoutFavouritesInput>;
}

export interface WorkCreateOneWithoutFavouritesInput {
  create?: Maybe<WorkCreateWithoutFavouritesInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface WorkUpdateOneRequiredWithoutFavouritesInput {
  create?: Maybe<WorkCreateWithoutFavouritesInput>;
  update?: Maybe<WorkUpdateWithoutFavouritesDataInput>;
  upsert?: Maybe<WorkUpsertWithoutFavouritesInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface ReportCreateManyWithoutWorkInput {
  create?: Maybe<ReportCreateWithoutWorkInput[] | ReportCreateWithoutWorkInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface WorkUpdateWithoutFavouritesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface UserCreateOneWithoutReportsInput {
  create?: Maybe<UserCreateWithoutReportsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ReportUpdateManyWithoutWorkInput {
  create?: Maybe<ReportCreateWithoutWorkInput[] | ReportCreateWithoutWorkInput>;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutWorkInput[]
    | ReportUpdateWithWhereUniqueWithoutWorkInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutWorkInput[]
    | ReportUpsertWithWhereUniqueWithoutWorkInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<
    | ReportUpdateManyWithWhereNestedInput[]
    | ReportUpdateManyWithWhereNestedInput
  >;
}

export interface CommentCreateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface ReportUpdateWithWhereUniqueWithoutWorkInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutWorkDataInput;
}

export interface WorkCreateOneWithoutCommentsInput {
  create?: Maybe<WorkCreateWithoutCommentsInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface ReportUpdateWithoutWorkDataInput {
  reason?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutReportsInput>;
}

export interface FollowCreateManyWithoutFollowingInput {
  create?: Maybe<
    FollowCreateWithoutFollowingInput[] | FollowCreateWithoutFollowingInput
  >;
  connect?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<UserCreateWithoutReportsInput>;
  update?: Maybe<UserUpdateWithoutReportsDataInput>;
  upsert?: Maybe<UserUpsertWithoutReportsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateOneWithoutFollowersInput {
  create?: Maybe<UserCreateWithoutFollowersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutReportsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface ReportCreateManyWithoutUserInput {
  create?: Maybe<ReportCreateWithoutUserInput[] | ReportCreateWithoutUserInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface CommentUpdateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutUserInput[]
    | CommentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutUserInput[]
    | CommentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface WorkCreateOneWithoutReportsInput {
  create?: Maybe<WorkCreateWithoutReportsInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutUserDataInput;
}

export interface CommentCreateManyWithoutWorkInput {
  create?: Maybe<
    CommentCreateWithoutWorkInput[] | CommentCreateWithoutWorkInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentUpdateWithoutUserDataInput {
  content?: Maybe<String>;
  work?: Maybe<WorkUpdateOneRequiredWithoutCommentsInput>;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface WorkUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<WorkCreateWithoutCommentsInput>;
  update?: Maybe<WorkUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<WorkUpsertWithoutCommentsInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface FollowCreateManyWithoutFollowersInput {
  create?: Maybe<
    FollowCreateWithoutFollowersInput[] | FollowCreateWithoutFollowersInput
  >;
  connect?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
}

export interface WorkUpdateWithoutCommentsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
}

export interface UserCreateOneWithoutFollowingInput {
  create?: Maybe<UserCreateWithoutFollowingInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface WorkUpsertWithoutCommentsInput {
  update: WorkUpdateWithoutCommentsDataInput;
  create: WorkCreateWithoutCommentsInput;
}

export interface CategoryUpdateInput {
  name?: Maybe<String>;
  works?: Maybe<WorkUpdateManyWithoutCategoryInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutUserDataInput;
  create: CommentCreateWithoutUserInput;
}

export interface VoiceDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VoiceDataWhereInput>;
  AND?: Maybe<
    VoiceDataSubscriptionWhereInput[] | VoiceDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    VoiceDataSubscriptionWhereInput[] | VoiceDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VoiceDataSubscriptionWhereInput[] | VoiceDataSubscriptionWhereInput
  >;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface LikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LikeWhereInput>;
  AND?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
  OR?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
  NOT?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface FavouriteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FavouriteWhereInput>;
  AND?: Maybe<
    FavouriteSubscriptionWhereInput[] | FavouriteSubscriptionWhereInput
  >;
  OR?: Maybe<
    FavouriteSubscriptionWhereInput[] | FavouriteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FavouriteSubscriptionWhereInput[] | FavouriteSubscriptionWhereInput
  >;
}

export interface CommentUpdateManyDataInput {
  content?: Maybe<String>;
}

export interface WorkUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
}

export interface FollowUpdateManyWithoutFollowingInput {
  create?: Maybe<
    FollowCreateWithoutFollowingInput[] | FollowCreateWithoutFollowingInput
  >;
  delete?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  connect?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  set?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  disconnect?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  update?: Maybe<
    | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    | FollowUpdateWithWhereUniqueWithoutFollowingInput
  >;
  upsert?: Maybe<
    | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    | FollowUpsertWithWhereUniqueWithoutFollowingInput
  >;
  deleteMany?: Maybe<FollowScalarWhereInput[] | FollowScalarWhereInput>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FollowUpdateWithWhereUniqueWithoutFollowingInput {
  where: FollowWhereUniqueInput;
  data: FollowUpdateWithoutFollowingDataInput;
}

export type FavouriteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FollowUpdateWithoutFollowingDataInput {
  followers?: Maybe<UserUpdateOneRequiredWithoutFollowersInput>;
}

export type FollowWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutFollowersInput {
  create?: Maybe<UserCreateWithoutFollowersInput>;
  update?: Maybe<UserUpdateWithoutFollowersDataInput>;
  upsert?: Maybe<UserUpsertWithoutFollowersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type ImageDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithoutFollowersDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
}

export type LikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReportUpdateManyWithoutUserInput {
  create?: Maybe<ReportCreateWithoutUserInput[] | ReportCreateWithoutUserInput>;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutUserInput[]
    | ReportUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutUserInput[]
    | ReportUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<
    | ReportUpdateManyWithWhereNestedInput[]
    | ReportUpdateManyWithWhereNestedInput
  >;
}

export type ReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReportUpdateWithWhereUniqueWithoutUserInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutUserDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ReportUpdateWithoutUserDataInput {
  reason?: Maybe<String>;
  work?: Maybe<WorkUpdateOneRequiredWithoutReportsInput>;
}

export interface WorkCreateOneWithoutImageDatasInput {
  create?: Maybe<WorkCreateWithoutImageDatasInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface WorkUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<WorkCreateWithoutReportsInput>;
  update?: Maybe<WorkUpdateWithoutReportsDataInput>;
  upsert?: Maybe<WorkUpsertWithoutReportsInput>;
  connect?: Maybe<WorkWhereUniqueInput>;
}

export interface FollowCreateInput {
  id?: Maybe<ID_Input>;
  following: UserCreateOneWithoutFollowingInput;
  followers: UserCreateOneWithoutFollowersInput;
}

export interface WorkUpdateWithoutReportsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface CommentUpdateManyMutationInput {
  content?: Maybe<String>;
}

export interface CommentUpdateManyWithoutWorkInput {
  create?: Maybe<
    CommentCreateWithoutWorkInput[] | CommentCreateWithoutWorkInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutWorkInput[]
    | CommentUpdateWithWhereUniqueWithoutWorkInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutWorkInput[]
    | CommentUpsertWithWhereUniqueWithoutWorkInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface WorkCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutWorkInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutWorkDataInput;
}

export interface LikeCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  work: WorkCreateOneWithoutLikesInput;
}

export interface CommentUpdateWithoutWorkDataInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
}

export interface CategoryCreateWithoutWorksInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface VoiceDataCreateWithoutWorkInput {
  id?: Maybe<ID_Input>;
  fileUrl: String;
}

export interface UserUpdateWithoutCommentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  following?: Maybe<FollowUpdateManyWithoutFollowingInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface UserCreateWithoutFavouritesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface FollowUpdateManyWithoutFollowersInput {
  create?: Maybe<
    FollowCreateWithoutFollowersInput[] | FollowCreateWithoutFollowersInput
  >;
  delete?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  connect?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  set?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  disconnect?: Maybe<FollowWhereUniqueInput[] | FollowWhereUniqueInput>;
  update?: Maybe<
    | FollowUpdateWithWhereUniqueWithoutFollowersInput[]
    | FollowUpdateWithWhereUniqueWithoutFollowersInput
  >;
  upsert?: Maybe<
    | FollowUpsertWithWhereUniqueWithoutFollowersInput[]
    | FollowUpsertWithWhereUniqueWithoutFollowersInput
  >;
  deleteMany?: Maybe<FollowScalarWhereInput[] | FollowScalarWhereInput>;
}

export interface LikeCreateWithoutWorkInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutLikesInput;
}

export interface FollowUpdateWithWhereUniqueWithoutFollowersInput {
  where: FollowWhereUniqueInput;
  data: FollowUpdateWithoutFollowersDataInput;
}

export interface FavouriteCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  work: WorkCreateOneWithoutFavouritesInput;
}

export interface FollowUpdateWithoutFollowersDataInput {
  following?: Maybe<UserUpdateOneRequiredWithoutFollowingInput>;
}

export interface ReportCreateWithoutWorkInput {
  id?: Maybe<ID_Input>;
  reason: String;
  user: UserCreateOneWithoutReportsInput;
}

export interface UserUpdateOneRequiredWithoutFollowingInput {
  create?: Maybe<UserCreateWithoutFollowingInput>;
  update?: Maybe<UserUpdateWithoutFollowingDataInput>;
  upsert?: Maybe<UserUpsertWithoutFollowingInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CommentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  content: String;
  work: WorkCreateOneWithoutCommentsInput;
}

export interface UserUpdateWithoutFollowingDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
  works?: Maybe<WorkUpdateManyWithoutUserInput>;
  likes?: Maybe<LikeUpdateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutUserInput>;
  reports?: Maybe<ReportUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  followers?: Maybe<FollowUpdateManyWithoutFollowersInput>;
}

export interface FollowCreateWithoutFollowingInput {
  id?: Maybe<ID_Input>;
  followers: UserCreateOneWithoutFollowersInput;
}

export interface UserUpsertWithoutFollowingInput {
  update: UserUpdateWithoutFollowingDataInput;
  create: UserCreateWithoutFollowingInput;
}

export interface ReportCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  reason: String;
  work: WorkCreateOneWithoutReportsInput;
}

export interface FollowUpsertWithWhereUniqueWithoutFollowersInput {
  where: FollowWhereUniqueInput;
  update: FollowUpdateWithoutFollowersDataInput;
  create: FollowCreateWithoutFollowersInput;
}

export interface CommentCreateWithoutWorkInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
}

export interface FollowScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FollowScalarWhereInput[] | FollowScalarWhereInput>;
  OR?: Maybe<FollowScalarWhereInput[] | FollowScalarWhereInput>;
  NOT?: Maybe<FollowScalarWhereInput[] | FollowScalarWhereInput>;
}

export interface FollowCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  following: UserCreateOneWithoutFollowingInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface WorkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkWhereInput>;
  AND?: Maybe<WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput>;
  OR?: Maybe<WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput>;
  NOT?: Maybe<WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutWorkInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutWorkDataInput;
  create: CommentCreateWithoutWorkInput;
}

export interface ImageDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageDataWhereInput>;
  AND?: Maybe<
    ImageDataSubscriptionWhereInput[] | ImageDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    ImageDataSubscriptionWhereInput[] | ImageDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ImageDataSubscriptionWhereInput[] | ImageDataSubscriptionWhereInput
  >;
}

export interface WorkUpsertWithoutReportsInput {
  update: WorkUpdateWithoutReportsDataInput;
  create: WorkCreateWithoutReportsInput;
}

export interface WorkCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface ReportUpsertWithWhereUniqueWithoutUserInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutUserDataInput;
  create: ReportCreateWithoutUserInput;
}

export interface WorkCreateWithoutVoiceDatasInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface ReportScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  OR?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  NOT?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
}

export interface ReportUpdateManyMutationInput {
  reason?: Maybe<String>;
}

export interface ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput;
  data: ReportUpdateManyDataInput;
}

export interface WorkUpsertWithoutImageDatasInput {
  update: WorkUpdateWithoutImageDatasDataInput;
  create: WorkCreateWithoutImageDatasInput;
}

export interface ReportUpdateManyDataInput {
  reason?: Maybe<String>;
}

export interface ImageDataCreateInput {
  id?: Maybe<ID_Input>;
  fileUrl: String;
  work: WorkCreateOneWithoutImageDatasInput;
}

export interface UserUpsertWithoutFollowersInput {
  update: UserUpdateWithoutFollowersDataInput;
  create: UserCreateWithoutFollowersInput;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  works?: Maybe<WorkCreateManyWithoutCategoryInput>;
}

export interface FollowUpsertWithWhereUniqueWithoutFollowingInput {
  where: FollowWhereUniqueInput;
  update: FollowUpdateWithoutFollowingDataInput;
  create: FollowCreateWithoutFollowingInput;
}

export interface WorkCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface UserUpsertWithoutReportsInput {
  update: UserUpdateWithoutReportsDataInput;
  create: UserCreateWithoutReportsInput;
}

export interface FavouriteCreateWithoutWorkInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutFavouritesInput;
}

export interface ReportUpsertWithWhereUniqueWithoutWorkInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutWorkDataInput;
  create: ReportCreateWithoutWorkInput;
}

export interface UserCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface WorkUpsertWithoutFavouritesInput {
  update: WorkUpdateWithoutFavouritesDataInput;
  create: WorkCreateWithoutFavouritesInput;
}

export interface UserCreateWithoutReportsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface FavouriteUpsertWithWhereUniqueWithoutUserInput {
  where: FavouriteWhereUniqueInput;
  update: FavouriteUpdateWithoutUserDataInput;
  create: FavouriteCreateWithoutUserInput;
}

export interface UserCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
}

export interface FavouriteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FavouriteScalarWhereInput[] | FavouriteScalarWhereInput>;
  OR?: Maybe<FavouriteScalarWhereInput[] | FavouriteScalarWhereInput>;
  NOT?: Maybe<FavouriteScalarWhereInput[] | FavouriteScalarWhereInput>;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface UserUpsertWithoutLikesInput {
  update: UserUpdateWithoutLikesDataInput;
  create: UserCreateWithoutLikesInput;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportWhereInput>;
  AND?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  OR?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  NOT?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
}

export interface LikeUpsertWithWhereUniqueWithoutWorkInput {
  where: LikeWhereUniqueInput;
  update: LikeUpdateWithoutWorkDataInput;
  create: LikeCreateWithoutWorkInput;
}

export interface WorkUpdateWithoutVoiceDatasDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutWorksInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutWorksInput>;
  imageDatas?: Maybe<ImageDataUpdateManyWithoutWorkInput>;
  likes?: Maybe<LikeUpdateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteUpdateManyWithoutWorkInput>;
  reports?: Maybe<ReportUpdateManyWithoutWorkInput>;
  comments?: Maybe<CommentUpdateManyWithoutWorkInput>;
}

export interface LikeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  OR?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  NOT?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface LikeUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutLikesInput>;
  work?: Maybe<WorkUpdateOneRequiredWithoutLikesInput>;
}

export interface WorkUpsertWithWhereUniqueWithoutUserInput {
  where: WorkWhereUniqueInput;
  update: WorkUpdateWithoutUserDataInput;
  create: WorkCreateWithoutUserInput;
}

export interface FavouriteUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutFavouritesInput>;
  work?: Maybe<WorkUpdateOneRequiredWithoutFavouritesInput>;
}

export interface WorkScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  visibility_not?: Maybe<Boolean>;
  views?: Maybe<Int>;
  views_not?: Maybe<Int>;
  views_in?: Maybe<Int[] | Int>;
  views_not_in?: Maybe<Int[] | Int>;
  views_lt?: Maybe<Int>;
  views_lte?: Maybe<Int>;
  views_gt?: Maybe<Int>;
  views_gte?: Maybe<Int>;
  usage?: Maybe<Int>;
  usage_not?: Maybe<Int>;
  usage_in?: Maybe<Int[] | Int>;
  usage_not_in?: Maybe<Int[] | Int>;
  usage_lt?: Maybe<Int>;
  usage_lte?: Maybe<Int>;
  usage_gt?: Maybe<Int>;
  usage_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<WorkScalarWhereInput[] | WorkScalarWhereInput>;
  OR?: Maybe<WorkScalarWhereInput[] | WorkScalarWhereInput>;
  NOT?: Maybe<WorkScalarWhereInput[] | WorkScalarWhereInput>;
}

export interface ImageDataCreateWithoutWorkInput {
  id?: Maybe<ID_Input>;
  fileUrl: String;
}

export interface WorkUpdateManyWithWhereNestedInput {
  where: WorkScalarWhereInput;
  data: WorkUpdateManyDataInput;
}

export interface WorkCreateWithoutFavouritesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface WorkUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  visibility?: Maybe<Boolean>;
  views?: Maybe<Int>;
  usage?: Maybe<Int>;
}

export interface WorkCreateWithoutReportsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface UserUpsertWithoutFavouritesInput {
  update: UserUpdateWithoutFavouritesDataInput;
  create: UserCreateWithoutFavouritesInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface FavouriteUpsertWithWhereUniqueWithoutWorkInput {
  where: FavouriteWhereUniqueInput;
  update: FavouriteUpdateWithoutWorkDataInput;
  create: FavouriteCreateWithoutWorkInput;
}

export interface ImageDataUpdateInput {
  fileUrl?: Maybe<String>;
  work?: Maybe<WorkUpdateOneRequiredWithoutImageDatasInput>;
}

export interface WorkUpsertWithWhereUniqueWithoutCategoryInput {
  where: WorkWhereUniqueInput;
  update: WorkUpdateWithoutCategoryDataInput;
  create: WorkCreateWithoutCategoryInput;
}

export interface UserUpsertWithoutWorksInput {
  update: UserUpdateWithoutWorksDataInput;
  create: UserCreateWithoutWorksInput;
}

export interface LikeUpsertWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput;
  update: LikeUpdateWithoutUserDataInput;
  create: LikeCreateWithoutUserInput;
}

export interface WorkUpsertWithoutLikesInput {
  update: WorkUpdateWithoutLikesDataInput;
  create: WorkCreateWithoutLikesInput;
}

export interface UserCreateWithoutWorksInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  following?: Maybe<FollowCreateManyWithoutFollowingInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  imageUrl?: Maybe<String>;
  role?: Maybe<Role>;
}

export interface UserCreateWithoutFollowingInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  works?: Maybe<WorkCreateManyWithoutUserInput>;
  likes?: Maybe<LikeCreateManyWithoutUserInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutUserInput>;
  reports?: Maybe<ReportCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  followers?: Maybe<FollowCreateManyWithoutFollowersInput>;
}

export interface WorkCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  user: UserCreateOneWithoutWorksInput;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
}

export interface WorkCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  category: CategoryCreateOneWithoutWorksInput;
  imageDatas?: Maybe<ImageDataCreateManyWithoutWorkInput>;
  voiceDatas?: Maybe<VoiceDataCreateManyWithoutWorkInput>;
  likes?: Maybe<LikeCreateManyWithoutWorkInput>;
  favourites?: Maybe<FavouriteCreateManyWithoutWorkInput>;
  reports?: Maybe<ReportCreateManyWithoutWorkInput>;
  comments?: Maybe<CommentCreateManyWithoutWorkInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WorkPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WorkPreviousValuesPromise
  extends Promise<WorkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  visibility: () => Promise<Boolean>;
  views: () => Promise<Int>;
  usage: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WorkPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  visibility: () => Promise<AsyncIterator<Boolean>>;
  views: () => Promise<AsyncIterator<Int>>;
  usage: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  imageUrl: () => Promise<String>;
  role: () => Promise<Role>;
  works: <T = FragmentableArray<Work>>(args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favourites: <T = FragmentableArray<Favourite>>(args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = FragmentableArray<Follow>>(args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<Follow>>(args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  works: <T = Promise<AsyncIterator<WorkSubscription>>>(args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = Promise<AsyncIterator<LikeSubscription>>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favourites: <T = Promise<AsyncIterator<FavouriteSubscription>>>(args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = Promise<AsyncIterator<FollowSubscription>>>(args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = Promise<AsyncIterator<FollowSubscription>>>(args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  imageUrl: () => Promise<String>;
  role: () => Promise<Role>;
  works: <T = FragmentableArray<Work>>(args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favourites: <T = FragmentableArray<Favourite>>(args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = FragmentableArray<Follow>>(args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<Follow>>(args?: {
    where?: FollowWhereInput;
    orderBy?: FollowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface Work {
  id: ID_Output;
  name: String;
  description: String;
  visibility: Boolean;
  views: Int;
  usage: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WorkPromise extends Promise<Work>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  visibility: () => Promise<Boolean>;
  views: () => Promise<Int>;
  usage: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  category: <T = CategoryPromise>() => T;
  imageDatas: <T = FragmentableArray<ImageData>>(args?: {
    where?: ImageDataWhereInput;
    orderBy?: ImageDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  voiceDatas: <T = FragmentableArray<VoiceData>>(args?: {
    where?: VoiceDataWhereInput;
    orderBy?: VoiceDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favourites: <T = FragmentableArray<Favourite>>(args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WorkSubscription
  extends Promise<AsyncIterator<Work>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  visibility: () => Promise<AsyncIterator<Boolean>>;
  views: () => Promise<AsyncIterator<Int>>;
  usage: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  imageDatas: <T = Promise<AsyncIterator<ImageDataSubscription>>>(args?: {
    where?: ImageDataWhereInput;
    orderBy?: ImageDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  voiceDatas: <T = Promise<AsyncIterator<VoiceDataSubscription>>>(args?: {
    where?: VoiceDataWhereInput;
    orderBy?: VoiceDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = Promise<AsyncIterator<LikeSubscription>>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favourites: <T = Promise<AsyncIterator<FavouriteSubscription>>>(args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WorkNullablePromise
  extends Promise<Work | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  visibility: () => Promise<Boolean>;
  views: () => Promise<Int>;
  usage: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  category: <T = CategoryPromise>() => T;
  imageDatas: <T = FragmentableArray<ImageData>>(args?: {
    where?: ImageDataWhereInput;
    orderBy?: ImageDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  voiceDatas: <T = FragmentableArray<VoiceData>>(args?: {
    where?: VoiceDataWhereInput;
    orderBy?: VoiceDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likes: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favourites: <T = FragmentableArray<Favourite>>(args?: {
    where?: FavouriteWhereInput;
    orderBy?: FavouriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VoiceData {
  id: ID_Output;
  fileUrl: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VoiceDataPromise extends Promise<VoiceData>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileUrl: () => Promise<String>;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VoiceDataSubscription
  extends Promise<AsyncIterator<VoiceData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileUrl: () => Promise<AsyncIterator<String>>;
  work: <T = WorkSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VoiceDataNullablePromise
  extends Promise<VoiceData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileUrl: () => Promise<String>;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateWork {
  count: Int;
}

export interface AggregateWorkPromise
  extends Promise<AggregateWork>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkSubscription
  extends Promise<AsyncIterator<AggregateWork>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Category {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  works: <T = FragmentableArray<Work>>(args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  works: <T = Promise<AsyncIterator<WorkSubscription>>>(args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  works: <T = FragmentableArray<Work>>(args?: {
    where?: WorkWhereInput;
    orderBy?: WorkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WorkConnection {
  pageInfo: PageInfo;
  edges: WorkEdge[];
}

export interface WorkConnectionPromise
  extends Promise<WorkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkEdge>>() => T;
  aggregate: <T = AggregateWorkPromise>() => T;
}

export interface WorkConnectionSubscription
  extends Promise<AsyncIterator<WorkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface VoiceDataEdge {
  node: VoiceData;
  cursor: String;
}

export interface VoiceDataEdgePromise
  extends Promise<VoiceDataEdge>,
    Fragmentable {
  node: <T = VoiceDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoiceDataEdgeSubscription
  extends Promise<AsyncIterator<VoiceDataEdge>>,
    Fragmentable {
  node: <T = VoiceDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise
  extends Promise<AggregateReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise
  extends Promise<ReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LikeEdge {
  node: Like;
  cursor: String;
}

export interface LikeEdgePromise extends Promise<LikeEdge>, Fragmentable {
  node: <T = LikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LikeEdgeSubscription
  extends Promise<AsyncIterator<LikeEdge>>,
    Fragmentable {
  node: <T = LikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageData {
  id: ID_Output;
  fileUrl: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImageDataPromise extends Promise<ImageData>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileUrl: () => Promise<String>;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImageDataSubscription
  extends Promise<AsyncIterator<ImageData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileUrl: () => Promise<AsyncIterator<String>>;
  work: <T = WorkSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageDataNullablePromise
  extends Promise<ImageData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileUrl: () => Promise<String>;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateImageData {
  count: Int;
}

export interface AggregateImageDataPromise
  extends Promise<AggregateImageData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageDataSubscription
  extends Promise<AsyncIterator<AggregateImageData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FavouriteSubscriptionPayload {
  mutation: MutationType;
  node: Favourite;
  updatedFields: String[];
  previousValues: FavouritePreviousValues;
}

export interface FavouriteSubscriptionPayloadPromise
  extends Promise<FavouriteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FavouritePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FavouritePreviousValuesPromise>() => T;
}

export interface FavouriteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FavouriteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FavouriteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FavouritePreviousValuesSubscription>() => T;
}

export interface ImageDataConnection {
  pageInfo: PageInfo;
  edges: ImageDataEdge[];
}

export interface ImageDataConnectionPromise
  extends Promise<ImageDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageDataEdge>>() => T;
  aggregate: <T = AggregateImageDataPromise>() => T;
}

export interface ImageDataConnectionSubscription
  extends Promise<AsyncIterator<ImageDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageDataSubscription>() => T;
}

export interface FavouritePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FavouritePreviousValuesPromise
  extends Promise<FavouritePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavouritePreviousValuesSubscription
  extends Promise<AsyncIterator<FavouritePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FollowEdge {
  node: Follow;
  cursor: String;
}

export interface FollowEdgePromise extends Promise<FollowEdge>, Fragmentable {
  node: <T = FollowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FollowEdgeSubscription
  extends Promise<AsyncIterator<FollowEdge>>,
    Fragmentable {
  node: <T = FollowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFollow {
  count: Int;
}

export interface AggregateFollowPromise
  extends Promise<AggregateFollow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFollowSubscription
  extends Promise<AsyncIterator<AggregateFollow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Favourite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FavouritePromise extends Promise<Favourite>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavouriteSubscription
  extends Promise<AsyncIterator<Favourite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  work: <T = WorkSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FavouriteNullablePromise
  extends Promise<Favourite | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FollowConnection {
  pageInfo: PageInfo;
  edges: FollowEdge[];
}

export interface FollowConnectionPromise
  extends Promise<FollowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FollowEdge>>() => T;
  aggregate: <T = AggregateFollowPromise>() => T;
}

export interface FollowConnectionSubscription
  extends Promise<AsyncIterator<FollowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FollowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFollowSubscription>() => T;
}

export interface AggregateFavourite {
  count: Int;
}

export interface AggregateFavouritePromise
  extends Promise<AggregateFavourite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFavouriteSubscription
  extends Promise<AsyncIterator<AggregateFavourite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FavouriteEdge {
  node: Favourite;
  cursor: String;
}

export interface FavouriteEdgePromise
  extends Promise<FavouriteEdge>,
    Fragmentable {
  node: <T = FavouritePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FavouriteEdgeSubscription
  extends Promise<AsyncIterator<FavouriteEdge>>,
    Fragmentable {
  node: <T = FavouriteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FollowSubscriptionPayload {
  mutation: MutationType;
  node: Follow;
  updatedFields: String[];
  previousValues: FollowPreviousValues;
}

export interface FollowSubscriptionPayloadPromise
  extends Promise<FollowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FollowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FollowPreviousValuesPromise>() => T;
}

export interface FollowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FollowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FollowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FollowPreviousValuesSubscription>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface FollowPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FollowPreviousValuesPromise
  extends Promise<FollowPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FollowPreviousValuesSubscription
  extends Promise<AsyncIterator<FollowPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WorkSubscriptionPayload {
  mutation: MutationType;
  node: Work;
  updatedFields: String[];
  previousValues: WorkPreviousValues;
}

export interface WorkSubscriptionPayloadPromise
  extends Promise<WorkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkPreviousValuesPromise>() => T;
}

export interface WorkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkPreviousValuesSubscription>() => T;
}

export interface Follow {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FollowPromise extends Promise<Follow>, Fragmentable {
  id: () => Promise<ID_Output>;
  following: <T = UserPromise>() => T;
  followers: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FollowSubscription
  extends Promise<AsyncIterator<Follow>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  following: <T = UserSubscription>() => T;
  followers: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FollowNullablePromise
  extends Promise<Follow | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  following: <T = UserPromise>() => T;
  followers: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WorkEdge {
  node: Work;
  cursor: String;
}

export interface WorkEdgePromise extends Promise<WorkEdge>, Fragmentable {
  node: <T = WorkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkEdgeSubscription
  extends Promise<AsyncIterator<WorkEdge>>,
    Fragmentable {
  node: <T = WorkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageDataSubscriptionPayload {
  mutation: MutationType;
  node: ImageData;
  updatedFields: String[];
  previousValues: ImageDataPreviousValues;
}

export interface ImageDataSubscriptionPayloadPromise
  extends Promise<ImageDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImageDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImageDataPreviousValuesPromise>() => T;
}

export interface ImageDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImageDataPreviousValuesSubscription>() => T;
}

export interface VoiceDataConnection {
  pageInfo: PageInfo;
  edges: VoiceDataEdge[];
}

export interface VoiceDataConnectionPromise
  extends Promise<VoiceDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoiceDataEdge>>() => T;
  aggregate: <T = AggregateVoiceDataPromise>() => T;
}

export interface VoiceDataConnectionSubscription
  extends Promise<AsyncIterator<VoiceDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoiceDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoiceDataSubscription>() => T;
}

export interface ImageDataPreviousValues {
  id: ID_Output;
  fileUrl: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImageDataPreviousValuesPromise
  extends Promise<ImageDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImageDataPreviousValuesSubscription
  extends Promise<AsyncIterator<ImageDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VoiceDataPreviousValues {
  id: ID_Output;
  fileUrl: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VoiceDataPreviousValuesPromise
  extends Promise<VoiceDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VoiceDataPreviousValuesSubscription
  extends Promise<AsyncIterator<VoiceDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Comment {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  work: <T = WorkSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateLike {
  count: Int;
}

export interface AggregateLikePromise
  extends Promise<AggregateLike>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLikeSubscription
  extends Promise<AsyncIterator<AggregateLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LikeSubscriptionPayload {
  mutation: MutationType;
  node: Like;
  updatedFields: String[];
  previousValues: LikePreviousValues;
}

export interface LikeSubscriptionPayloadPromise
  extends Promise<LikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LikePreviousValuesPromise>() => T;
}

export interface LikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LikePreviousValuesSubscription>() => T;
}

export interface ImageDataEdge {
  node: ImageData;
  cursor: String;
}

export interface ImageDataEdgePromise
  extends Promise<ImageDataEdge>,
    Fragmentable {
  node: <T = ImageDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageDataEdgeSubscription
  extends Promise<AsyncIterator<ImageDataEdge>>,
    Fragmentable {
  node: <T = ImageDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LikePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LikePreviousValuesPromise
  extends Promise<LikePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LikePreviousValuesSubscription
  extends Promise<AsyncIterator<LikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Report {
  id: ID_Output;
  reason: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportSubscription
  extends Promise<AsyncIterator<Report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  work: <T = WorkSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportNullablePromise
  extends Promise<Report | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Like {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LikePromise extends Promise<Like>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LikeSubscription
  extends Promise<AsyncIterator<Like>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  work: <T = WorkSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LikeNullablePromise
  extends Promise<Like | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  work: <T = WorkPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LikeConnection {
  pageInfo: PageInfo;
  edges: LikeEdge[];
}

export interface LikeConnectionPromise
  extends Promise<LikeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LikeEdge>>() => T;
  aggregate: <T = AggregateLikePromise>() => T;
}

export interface LikeConnectionSubscription
  extends Promise<AsyncIterator<LikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLikeSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  imageUrl: String;
  role: Role;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  imageUrl: () => Promise<String>;
  role: () => Promise<Role>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface VoiceDataSubscriptionPayload {
  mutation: MutationType;
  node: VoiceData;
  updatedFields: String[];
  previousValues: VoiceDataPreviousValues;
}

export interface VoiceDataSubscriptionPayloadPromise
  extends Promise<VoiceDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VoiceDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VoiceDataPreviousValuesPromise>() => T;
}

export interface VoiceDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoiceDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoiceDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VoiceDataPreviousValuesSubscription>() => T;
}

export interface ReportPreviousValues {
  id: ID_Output;
  reason: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReportPreviousValuesPromise
  extends Promise<ReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FavouriteConnection {
  pageInfo: PageInfo;
  edges: FavouriteEdge[];
}

export interface FavouriteConnectionPromise
  extends Promise<FavouriteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FavouriteEdge>>() => T;
  aggregate: <T = AggregateFavouritePromise>() => T;
}

export interface FavouriteConnectionSubscription
  extends Promise<AsyncIterator<FavouriteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FavouriteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFavouriteSubscription>() => T;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription
  extends Promise<AsyncIterator<ReportEdge>>,
    Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVoiceData {
  count: Int;
}

export interface AggregateVoiceDataPromise
  extends Promise<AggregateVoiceData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoiceDataSubscription
  extends Promise<AsyncIterator<AggregateVoiceData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Work",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "ImageData",
    embedded: false
  },
  {
    name: "VoiceData",
    embedded: false
  },
  {
    name: "Like",
    embedded: false
  },
  {
    name: "Favourite",
    embedded: false
  },
  {
    name: "Report",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Follow",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/public-marshedge-281/fyp-api/dev`
});
export const prisma = new Prisma();
